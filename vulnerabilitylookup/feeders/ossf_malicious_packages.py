from __future__ import annotations

import re

import orjson
from pathlib import Path

from ..helpers import fromisoformat_wrapper

from .abstract_feeder import AbstractFeeder


class OSSFMaliciousPackages(AbstractFeeder):
    def __init__(self) -> None:
        super().__init__(Path(__file__).stem)

        self.init_git_repo()

    def update(self) -> bool:
        self.git.remotes.origin.pull("main")

        paths_to_import: set[Path] = set()
        if _last_update := self.storage.hget("last_updates", self.name):
            _last_update_str = _last_update.decode()
            if _last_update_str == self.git.head.commit.hexsha:
                # No changes
                self.logger.info("No new commit.")
                return False
            for commit in self.git.iter_commits(f"{_last_update_str}...HEAD"):
                for line in self.git.git.show(commit.hexsha, name_only=True).split("\n"):
                    if not line.endswith(".json"):
                        continue
                    p_path = self.path_to_repo / Path(line)
                    if p_path.exists() and re.match(r"MAL-\d-\d*", p_path.stem):
                        paths_to_import.add(p_path)

        else:
            # First run, get all files
            for malicious_package_entry in (self.path_to_repo / "osv" / "malicious").glob("**/*.json"):
                if malicious_package_entry.exists() and re.match(r"MAL-\d{4}-\d*", malicious_package_entry.stem):
                    paths_to_import.add(malicious_package_entry)

        if not paths_to_import:
            return False

        p = self.storage.pipeline()
        gsids: dict[str, float] = {}
        for path in paths_to_import:
            print(path)
            # Store all cves individually
            with path.open() as vuln_entry:
                vuln = orjson.loads(vuln_entry.read())
                modified = fromisoformat_wrapper(vuln["modified"])
                vuln_id = path.stem.lower()
                gsids[vuln_id] = modified.timestamp()
                if "aliases" in vuln and vuln.get("aliases"):
                    for alias in vuln.get("aliases"):
                        a = alias.lower()
                        p.sadd(f"{vuln_id}:link", a)
                        p.sadd(f"{a}:link", vuln_id)
                p.set(vuln_id, orjson.dumps(vuln))
            if len(gsids) > 1000:
                # Avoid a massive execute on first import
                p.zadd(f"index:{self.name}", gsids)  # type: ignore
                p.zadd("index", gsids)  # type: ignore
                p.execute()

                # reset pipeline
                p = self.storage.pipeline()
                gsids = {}

        if gsids:
            # remaining entries
            p.zadd(f"index:{self.name}", gsids)  # type: ignore
            p.zadd("index", gsids)  # type: ignore
            p.execute()
        self.storage.hset("last_updates", mapping={self.name: self.git.head.commit.hexsha})
        self.logger.info("Import done.")
        return True
