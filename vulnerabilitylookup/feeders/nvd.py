from __future__ import annotations

import requests

from datetime import datetime, timedelta
from pathlib import Path
import orjson
from uuid import uuid4
from ..helpers import fromisoformat_wrapper

from .abstract_feeder import AbstractFeeder


class NVD(AbstractFeeder):
    def __init__(self) -> None:
        super().__init__(Path(__file__).stem)
        if "apikey" in self.config:
            self.url_apikey_param = {"apiKey": self.config["apikey"]}
        else:
            self.url_apikey_param = {}

        self.url_api = "https://services.nvd.nist.gov/rest/json/cves/2.0/?"

    def update(self) -> bool:
        query: dict[str, int | str]
        last_update: datetime | None
        if _last_update_str := self.storage.hget("last_updates", self.name):
            last_update = fromisoformat_wrapper(_last_update_str.decode())
        else:
            last_update = None
        if last_update is None:
            query = {}
        else:
            query = {
                "lastModStartDate": (last_update - timedelta(hours=10)).isoformat(),
                "lastModEndDate": (datetime.now() - timedelta(seconds=10)).isoformat(),
            }

        last_update = datetime.now()
        self.logger.debug(f"nvd_query: {query}")

        index = 0
        totalResults = None
        results_per_page = None
        max_results_per_page = 500
        while True:
            query["startIndex"] = index
            query["resultsPerPage"] = max_results_per_page
            r = requests.get(self.url_api, params=query, headers=self.url_apikey_param)
            r.raise_for_status()
            nvd_value = r.json()
            if totalResults is None:
                totalResults = nvd_value["totalResults"]
                self.logger.debug(totalResults)
            results_per_page = len(nvd_value["vulnerabilities"])
            if not results_per_page:
                # No more CVEs
                break
            self.logger.debug(f"index:{index} totalResults:{totalResults}")
            index += results_per_page
            # Store all cves individually
            p = self.storage.pipeline()
            cves: dict[str, float] = {}
            for vuln in nvd_value["vulnerabilities"]:
                cve_id = vuln["cve"]["id"].lower()
                # do we already have a meta entry for this source?
                if _meta_uuid := self.storage.hget(f"{cve_id}:meta", self.name):
                    meta_uuid = _meta_uuid.decode()
                else:
                    meta_uuid = str(uuid4())
                self.storage.hset(f"{cve_id}:meta", mapping={self.name: meta_uuid})
                self.storage.set(f"{self.name}:{meta_uuid}", orjson.dumps(vuln))
                cves[cve_id] = fromisoformat_wrapper(vuln["cve"]["lastModified"]).timestamp()
                if not self.storage.exists(cve_id):
                    self.logger.warning(f"{cve_id} is missing.")

                if "configurations" in vuln["cve"]:
                    for configuration in vuln["cve"]["configurations"]:
                        if "nodes" not in configuration:
                            continue
                        for node in configuration["nodes"]:
                            if "cpeMatch" not in node:
                                continue
                            for cpematch in node["cpeMatch"]:
                                if "criteria" in cpematch:
                                    _, _, _, vendor, product, _ = cpematch["criteria"].split(":", 5)
                                    vendor = vendor.strip().lower()
                                    product = product.strip().lower()
                                    if not vendor or not product:
                                        # empty, or only spaces
                                        continue
                                    if "n/a" in vendor or "n/a" in product:
                                        continue
                                    p.sadd("vendors", vendor)
                                    p.sadd(f"{vendor}:products", product)
                                    p.sadd(f"{vendor}:vulnerabilities", cve_id)
                                    p.sadd(f"{vendor}:{product}:vulnerabilities", cve_id)

            p.zadd(f"index:{self.name}", cves)  # type: ignore
            p.execute()

            if results_per_page < max_results_per_page:
                break
        self.storage.hset("last_updates", mapping={self.name: last_update.isoformat()})
        self.logger.info("Import done.")
        return True
