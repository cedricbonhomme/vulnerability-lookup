from __future__ import annotations

import logging
import requests

from datetime import datetime
import orjson
from pathlib import Path
from uuid import uuid4

from ..helpers import fromisoformat_wrapper

from .abstract_feeder import AbstractFeeder


class CISAKnownExploited(AbstractFeeder):
    def __init__(self) -> None:
        super().__init__(Path(__file__).stem)
        self.url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"

    def _load_logging_config(self) -> None:
        cur_path = Path(__file__)
        if not (cur_path.parent / f"{cur_path.stem}_logging.json").exists():
            return
        with (cur_path.parent / f"{cur_path.stem}_logging.json").open() as f:
            log_config = orjson.loads(f.read())
        logging.config.dictConfig(log_config)

    def update(self) -> bool:
        last_update: datetime | None
        if _last_update_str := self.storage.hget("last_updates", self.name):
            last_update = fromisoformat_wrapper(_last_update_str.decode())
        else:
            last_update = None

        r = requests.get(self.url)
        try:
            r.raise_for_status()
        except Exception as e:
            self.logger.debug(f"Failed to fetch: {e}")
            return False

        known_exploited_vulnerabilities = r.json()
        current_update = fromisoformat_wrapper(known_exploited_vulnerabilities["dateReleased"])
        if last_update and current_update <= last_update:
            self.logger.debug(f"cisa_known_exploited: already loaded ({current_update})")
            return False

        index_cisa: dict[str, float] = {}
        for exploited_vuln in known_exploited_vulnerabilities["vulnerabilities"]:
            cve_id = exploited_vuln["cveID"].lower()
            # do we already have a meta entry for this source?
            if _meta_uuid := self.storage.hget(f"{cve_id}:meta", self.name):
                meta_uuid = _meta_uuid.decode()
            else:
                meta_uuid = str(uuid4())
                self.storage.hset(f"{cve_id}:meta", mapping={self.name: meta_uuid})
            # No proper identifier for this source, so we use an UUID
            self.storage.hset(f"{self.name}:{meta_uuid}", mapping=exploited_vuln)
            index_cisa[meta_uuid] = fromisoformat_wrapper(exploited_vuln["dateAdded"]).timestamp()

        # We do not store that in the index key as they are meta
        self.storage.zadd(f"index:{self.name}", index_cisa)  # type: ignore

        self.storage.hset("last_updates", mapping={self.name: current_update.isoformat()})
        self.logger.info("Import done.")
        return True
